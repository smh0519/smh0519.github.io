---
title: "[Pintos] User Mode와 Kernel Mode 완벽 정리"
date: 2025-11-23  # 작성 날짜에 맞춰 수정하세요
categories: [OS, Pintos]
tags: [Operating System, Kernel, User Mode, System Call]
---

> 운영체제(OS)가 프로세스를 어떻게 실행하는지 이해하려면

**User Mode와 Kernel Mode** 개념은 반드시 짚고 넘어가야 한다.  
특히 교육용 OS인 **Pintos**에서는 이 개념이 직접적으로 구현되므로  
정확히 알고 있어야 시스템 콜, 프로세스 실행, 메모리 구조를 설계할 수 있다.

---

## 왜 User Mode와 Kernel Mode를 알아야 하는가?

---

일반 프로그램은 CPU와 메모리를 마음대로 다룰 수 없다.  
그렇게 되면 **보안/안정성 문제가 즉시 발생**하기 때문이다.

그래서 OS는 CPU를 두 개의 모드로 나누어 운영한다:

-   **User Mode**: 일반 프로그램(유저 프로세스)이 실행되는 제한된 환경
-   **Kernel Mode**: OS 커널이 실행되는 최고 권한 환경

이 둘의 전환을 이해하면:

-   Pintos의 시스템 콜 구조
-   프로세스 주소 공간
-   user stack / kernel stack 차이
-   interrupt/trap 처리

이런 핵심 개념이 자연스럽게 이해된다.

---

## CPU의 권한 레벨과 두 가지 실행 모드

---

## User Mode란?

유저 모드에서는 프로그램이 **제한된 권한**으로 실행된다.

**특징:**

-   커널 메모리에 접근 불가
-   하드웨어 직접 제어 불가 (디스크, 네트워크 장치 등)
-   파일 읽기/쓰기, 메모리 관리 같은 작업을 직접 할 수 없음
-   반드시 **시스템 콜(system call)** 로 커널에게 요청해야 함

> 유저 프로그램이 사용할 수 있는 “안전한 실행 환경”

## Kernel Mode란?

운영체제 커널이 동작하는 모드로, CPU의 **모든 권한**을 사용할 수 있다.

특징:

-   메모리 전체 접근 가능
-   CPU 제어 가능
-   디스크/네트워크/디바이스 등 모든 하드웨어 직접 제어
-   시스템 자원 관리
-   프로세스 스케줄링 담당

> OS가 시스템 전체를 다루기 위한 “최고 권한 실행 환경”

| 구분 | User Mode | Kernel Mode |
| --- | --- | --- |
| 권한 | 제한적 | 최고 권한 |
| 목적 | 안전한 실행 환경 | 시스템 전체 제어 |
| 메모리 접근 | 사용자 영역만 | 전체 메모리 |
| 하드웨어 접근 | 불가 | 가능 |
| 위험 작업 | 시스템 콜로 요청 | 직접 수행 |

---

## System Call과 Trap

---

#### Trap(트랩)이란?

Trap = CPU가 User Mode → Kernel Mode로 전환되는 방식

**Trap의 특징**

-   CPU가 강제로 **Kernel Mode**로 전환됨
-   사용자 프로세스의 실행 상태(레지스터, PC)를 저

#### System Call(시스템 콜)이란?

사용자 프로그램이 **커널 자원을 사용하고 싶을 때 커널에게 요청하는 공식적인 인터페이스**.

**시스템 콜의 역할**

-   파일 읽기/쓰기
-   프로세스 생성
-   메모리 관리
-   네트워크 통신
-   하드웨어 접근

#### 왜 시스템 콜이 필요한가?

유저 모드는 다음 작업을 직접 할 수 없다:

-   파일을 읽는다 → 디스크 접근
-   네트워크 패킷 받는다 → NIC 접근
-   메모리를 새로 할당한다 → 페이지 테이블 접근
-   스레드 생성한다 → PCB 접근

이런 작업은 모두 **커널만 가능**하다.  
그래서 유저 프로그램은 시스템 콜을 호출해 커널에게 요청한다.

---

## 프로세스 실행 → 시스템 콜 처리까지 전체 흐름 순서

---

#### **1\. 프로세스가 User Mode에서 실행 중**

-   CPU는 **User Mode**에서 일반 사용자 프로그램 코드를 실행 중.
-   프로세스의 코드, 데이터, 스택을 사용하며 자기 주소공간에서 동작.

---

#### **2\. 프로그램이 시스템 자원 접근이 필요함**

예:

-   read()를 호출하여 파일 읽기
-   write() 호출
-   open() 호출
-   메모리 관련 처리 등

이러한 기능은 **커널만 실행할 수 있는 작업**이라 시스템 콜을 사용해야 함.

---

#### **3\. 시스템 콜 발생 (User → Kernel)**

-   프로그램이 read(), write() 같은 **라이브러리 함수**를 호출.
-   라이브러리 함수는 내부에서 **CPU 명령어 trap**(예: syscall, int 0x80)을 사용해 **커널로 진입**.
-   CPU는 모드를 **User Mode → Kernel Mode**로 바꿈.

---

#### **4\. User Mode의 실행 상태를 저장**

커널은 유저 프로그램의 현재 실행 정보를 저장함:

-   **PC(Program Counter)**: 어느 명령을 실행 중이었는지
-   **Register 값들**
-   **User Stack Pointer**
-   **프로세스 컨텍스트 전체**

이유: 커널 작업이 끝나고 나면 **정확히 이전 상태로 다시 돌아와서 실행을 재개해야 하기 때문**.

---

#### **5\. 커널이 시스템 콜 번호를 확인**

-   저장된 트랩 정보에서, 어떤 시스템 콜인지 확인  
    예:
-   read() → 시스템 콜 번호 0
-   write() → 번호 1
-   open() → 번호 2

---

#### **6\. 커널의 시스템 콜 핸들러 실행**

해당 시스템 콜에 대응하는 커널 함수(handler)가 실행됨.

예: read()라면 흐름은 이런 식:

1.  프로세스의 **파일 디스크립터 테이블(FDT)** 조회
2.  fd 번호가 가리키는 **open file table entry** 확인
3.  해당 파일이 test.c라면 test.c에 대한 inode, offset 가져옴
4.  디스크 드라이버 호출해 파일 내용 읽음
5.  읽은 데이터를 커널 버퍼에 저장
6.  유저 공간 버퍼로 데이터 복사

---

#### **7\. 시스템 콜 처리 완료 후 반환값 준비**

-   읽은 바이트 수 등 시스템 콜의 결과를 레지스터에 저장.
-   프로세스에게 “여기 결과 있다” 형태로 돌려줄 준비 완료.

---

#### **8\. 커널 Mode → User Mode 복귀**

-   저장했던 사용자 프로세스의 상태(PC, register, stack pointer)를 복원.
-   CPU 모드를 **Kernel → User**로 변경.
-   프로세스는 딱 중단됐던 코드 다음 줄부터 계속 실행됨.

---

#### **9\. User Mode에서 실행 재개**

프로그램이 다음과 같이 진행됨:

```
int n = read(fd, buf, 100);
// read()는 커널에서 처리된 결과를 돌려받고, 이후 코드 계속 진행
```

# 전체 요약 흐름

1.  **User Mode에서 실행**
2.  시스템 콜 호출 → **trap 발생**
3.  CPU → **Kernel Mode 전환**
4.  **유저 프로세스 상태 저장**
5.  커널이 **시스템 콜 핸들러 실행**
6.  커널이 파일·디스크·메모리 등 필요한 작업 수행
7.  **결과를 준비**
8.  CPU → **User Mode 복귀**
9.  저장했던 상태를 복원하고 다시 **유저 코드 실행 계속**